* {
    box-sizing: border-box;
}

/* Tuneamos la barra de navegación pisando las clases del framework. */

.navbar {
    padding: 0;
    background: white;
}

.navbar-nav {
    width: 100%;
    background: none;
    flex-wrap: nowrap;
}

/* Repartimos el ancho de los botones en partes iguales. */

.nav-item {
    flex: 1;
    padding: 0;
}

.nav-link {
    background-color: none;
    text-align: center;
}

/* Le damos un tamaño a las img de los botones y les aplicamos transparencia para poner como activa solo la vista actualmente en foco de navegación con opacidad 1. */

img[src*=".svg"] {
    height: 1.25em;
    opacity: .5;
}

/* Inicialmente, ponemos como activa la img del primer botón (la sección uno) con opacidad 1. */

nav .nav-item:nth-of-type(1) img[src*=".svg"] {
    opacity: 1;
}

/* Con cualquier page en target (los containers que tienen aplicado el attr data-role page que corresponden a cada vista de la app), pasamos a todas las img a opacidad .5 (para desmarcar la que estuviera activa ya que no sabemos cuál era). Por eso ubicamos el nav por debajo de todo el resto para poder seleccionarlo con el operador de hermanos (~). */

[data-role="page"]:target ~ nav .nav-item img[src*=".svg"] {
    opacity: .5;
}

/* Y luego evaluamos qué page está en target para marcar la img del botón correspondiente como activa con opacidad 1. */

#uno:target ~ nav .nav-item:nth-of-type(1) img[src*=".svg"] {
    opacity: 1;
}

#dos:target ~ nav .nav-item:nth-of-type(2) img[src*=".svg"] {
    opacity: 1;
}

#tres:target ~ nav .nav-item:nth-of-type(3) img[src*=".svg"] {
    opacity: 1;
}

#cuatro:target ~ nav .nav-item:nth-of-type(4) img[src*=".svg"] {
    opacity: 1;
}

/* Seleccionamos a todas las vistas (containers con attr data-role page) por atributo/valor y las ocultamos con display none. Además les damos posicionamiento absoluto y las ubicamos en el vértice superior izquierdo de la ventana del browser y les aplicamos un margen inferior del tamaño del nav ubicado en la parte inferior de la ventana con posición fija para que no queden tapadas en su contenido. */

[data-role="page"] {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    margin-bottom: 2.5rem;
}

/* Pero la vista uno le aplicamos display block para que se vea inicialmente. */


#uno {
    display: block;
}

/* Como la navegación es por target (o vínculo ancla) la vista en target se hace visible. */


[data-role="page"]:target {
    display: block;
}

/* Como se dijo, cuando carga el html la page uno aparece activa (display block) ya que debemos mostrar algo de contenido, luego, con cualquier otra page en target ocultamos la uno para que no quede por debajo de la vista en target (las demás están display none desde el comienzo). Del mismo modo que para el nav, ubicamos la vista uno por debajo de las demás para poder seleccionarla con el operador de hermanos (~). */

#dos:target ~ #uno,
#tres:target ~ #uno,
#cuatro:target ~ #uno {
    display: none;
}

.display-4 {
    font-size: 2rem;
}

/* Ubicamos a la derecha el botón que abre el modal. */

.btn_header {
    position: absolute;
    right: 20px;
    top: 15px;
}

/* Le damos un tamaño a los cards de la table-responsive para que scrolleen en el eje horizontal de manera interna en la tabla. */

.card_table {
    width: 40vw;
}

/* Le aplicamos el formato al alert que trabaja como publicidad en la vista inicial. */

.publicidad {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;    
    top:0;
    left: 0;
    z-index: 20000;
    border-radius: .25rem;
    background-color: rgba(0,0,0,.5);
}

/* Modificamos el aspecto del botón de cierre del alert. */

.alert .close {
    color: white;
    opacity: 1;
}

/* Y ajustamos el ancho máximo de la img de publicidad para que no crezca más alla de su ancho lo que la haría pixelar. */

.publicidad img {
    max-width: 100%;
}

/* Seleccionamos los párrafos de la vista 2 que tienen aplicada la clase text-truncate de BT (a los que les programamos también el click para quitarla o aplicarla en clicks sucesivos). Las propiedades comentadas son las que aplica la clase text-truncate, oculta el contenido excedente de la caja, agrega los ... cuando el texto excede en ancho a su contenedor y no permite el salto de línea del texto (nowrap) para forzarlo a exceder a su contenedor y generar el efecto. Pisamos esta última propiedad con el valor normal para que el texto no exceda el ancho del contenedor y luego aplicamos la propiedad line-clamp (del display box que es una propiedad todavía no estandar pero que los navegadores nuevos ya aplican) para determinar que el texto no pueda saltar de línea y así exceder al contenedor a partir de la línea 2, como se sigue aplicando el overflow hidden y el text-overflow desde la clase text-truncate de BT, se corta y el texto y aparecen los ... en la línea 2 (cambiando este valor se puede aplicar desde la tercera línea, cuarta, quinta, etc. */

p[class="text-truncate"] {
    /*overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;*/
    white-space: normal !important;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical; 
    
}
